# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();
```

- 10,使用 var 声明的变量使用函数作用域和全局作用域,当 a`[`6`]`()执行时,根据作用域链只能在全局作用域中找到 i,由于 for 循环结束 i 已经变成了 10,所以输出为 10

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

- 报错,因为 let 声明的变量使用块级作用域,即在 if(true)括起来的语句中只对 tmp 声明而未赋值

### 3. 结合 ES6 语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4];
```

- Math.min(...arr)

### 4. 请详细说明 var、let、const 三种声明变量的方式之间的具体差别

- var 声明的变量存在变量提升,可以先使用后定义,而 let 和 const 不行
- var 使用全局作用域和函数作用域,let 和 const 使用块级作用域,只能在所在的代码块中生效,外部无法访问
- const 声明的常量必须初始化,let 声明的变量不用
- const 定义常量的值不能再通过赋值修改,也不能再次声明,而 var 和 let 定义的变量值可以修改

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};
obj.fn();
```

- 20,箭头函数的 this 指向定义时的作用域的 this,即 obj

### 6. 简述 Symbol 类型的用途

1. 为对象添加独一无二的属性名,
2. 可实现私有属性,
3. 自定义 toString 标识符:[Symbol.toStringTag]:'myObject',
4. 实现迭代器:[Symbol.iterator],

### 7. 说说什么是浅拷贝，什么是深拷贝？

- 针对引用对象而言,浅拷贝只复制一层对象的属性,深拷贝递归复制了所有层级

### 8. 请简述 TypeScript 与 JavaScript 之间的关系？

- ts 是基于 js 的渐进式编程语言,是 js 的超集,扩展了 js 的类型系统及支持 es6+的新特性,通过编译成 js 代码执行

### 9. 请谈谈你所认为的 typescript 优缺点

- 优点: 1.拥有强类型语言的优点:能更早暴露错误,代码有智能提示,编码更准确,重构代码更牢靠,并减少不必要的类型判断 2.集成了 es6+的新特性,可代替 babel 转换成低版本代码,兼容性强 3.渐进式,对维护老旧代码具有优势
- 缺点:需要维护大量类型定义,且放弃了 js 的隐式类型推断和转换机制,需要更严格的编码,且相较于 js 多了许多新概念

### 10. 描述引用计数的工作原理和优缺点

- 优点:
  发现垃圾立即回收
  最大限度减少程序暂停
- 缺点:
  无法回收循环引用的对象
  时间开销大

### 11. 描述标记整理算法的工作流程

1. 遍历所有对象并标记活动对象,如果有子引用,则递归寻找可达对象并标记
2. 整理空间,移动对象位置使得可回收空间是连续的,然后回收空间

### 12.描述 V8 中新生代存储区垃圾回收的流程

1. 新生代内存区分为两个等大小空间,使用空间为 from,空闲空间为 to,活动对象存储于 from 空间,
2. 当 from 空间存储一定数据后触发垃圾回收,使用标记整理算法将活动对象拷贝至 to 空间,
3. 拷贝过程中可能出现晋升,如果有前一轮垃圾回收后还存活的新生代对象或者当前 to 空间使用率超过 25%,就会将新生代对象移动至老生代,
4. 然后将 from 空间释放,此时 to 和 from 交换完成垃圾回收

### 13. 描述增量标记算法在何时使用及工作原理

- 在老年代对象进行垃圾回收时使用增量标记进行效率优化
- 工作原理是将垃圾回收时遍历对象进行标记后,如果有子引用则将进行标记的工作拆分成多个标记阶段与程序执行阶段交替穿插执行,以避免因遍历标记长时间阻塞程序执行
